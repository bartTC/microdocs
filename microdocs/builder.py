"""
Build HTML documentation from Markdown files.

This module provides functionality to convert markdown files into a single,
self-contained HTML documentation site with navigation and table of contents.
"""

from __future__ import annotations

import html
import re
import sys
from datetime import UTC, datetime
from pathlib import Path
from typing import TYPE_CHECKING

import markdown
from jinja2 import Template
from pymdownx import emoji

if TYPE_CHECKING:
    from collections.abc import Sequence


def convert_markdown_to_html(md_content: str) -> tuple[str, markdown.Markdown]:
    """
    Convert markdown content to HTML with syntax highlighting and extensions.

    Args:
        md_content: Raw markdown content as string

    Returns:
        Tuple containing:
            - Converted HTML content as string
            - Markdown instance with parsed metadata (toc_tokens, etc.)

    """
    md = markdown.Markdown(
        extensions=[
            "extra",  # Includes: fenced_code, tables, attr_list, def_list, abbr, footnotes
            "toc",
            "mdx_truly_sane_lists",
            # GitHub-flavored markdown features
            "pymdownx.highlight",  # Syntax highlighting (replaces codehilite)
            "pymdownx.superfences",  # Better code fences (replaces fenced_code)
            "pymdownx.magiclink",  # Auto-link URLs
            "pymdownx.betterem",  # Better emphasis handling
            "pymdownx.tilde",  # ~~strikethrough~~
            "pymdownx.emoji",  # :emoji: support
            "pymdownx.tasklist",  # - [ ] task lists
        ],
        extension_configs={
            "mdx_truly_sane_lists": {
                "nested_indent": 2,
                "truly_sane": True,
            },
            "pymdownx.highlight": {
                "css_class": "highlight",
                "linenums": False,
            },
            "pymdownx.magiclink": {
                "repo_url_shorthand": True,
                "social_url_shorthand": True,
            },
            "pymdownx.emoji": {
                "emoji_index": emoji.twemoji,
                "emoji_generator": emoji.to_alt,
            },
            "pymdownx.tasklist": {
                "custom_checkbox": True,
            },
        },
    )
    html = md.convert(md_content)
    return html, md


def extract_title_from_markdown_instance(md: markdown.Markdown) -> str:
    """
    Extract the first H1 heading from parsed Markdown.

    Uses the TOC tokens generated by the Markdown 'toc' extension
    to find the first level-1 heading.

    Args:
        md: Markdown instance after conversion with 'toc' extension enabled

    Returns:
        The first H1 heading text, or "Documentation" if no H1 found.

    """
    if hasattr(md, "toc_tokens") and md.toc_tokens:
        for token in md.toc_tokens:
            if token.get("level") == 1:
                return token.get("name", "Documentation")
    return "Documentation"


def convert_plain_text_to_html(text_content: str) -> str:
    """
    Convert plain text to HTML with preserved line breaks.

    For non-markdown files, escapes HTML entities and converts
    newlines to <br> tags.

    Args:
        text_content: Plain text content as string

    Returns:
        HTML with line breaks preserved

    """
    escaped_content = html.escape(text_content)
    # Convert newlines to <br> tags
    html_with_breaks = escaped_content.replace("\n", "<br>\n")
    return f"<div>{html_with_breaks}</div>"


def rewrite_internal_links(html_content: str, section_ids: set[str]) -> str:
    """
    Rewrite links to markdown files into section navigation links.

    If a link points to a file that exists as a section (e.g., CHANGELOG.md),
    rewrite it to navigate to that section instead of loading the file.

    Args:
        html_content: HTML content with links
        section_ids: Set of section IDs (lowercased file stems)

    Returns:
        HTML with rewritten internal links

    """

    def replace_link(match: re.Match[str]) -> str:
        href = match.group(1)
        # Check if link is to a markdown file
        if href.endswith((".md", ".markdown")):
            # Extract the stem (filename without extension) and lowercase it
            link_stem = Path(href).stem.lower()
            # If this matches a section ID, rewrite to section link
            if link_stem in section_ids:
                return f'href="#{link_stem}"'
        return match.group(0)

    # Match href attributes in anchor tags
    return re.sub(r'href="([^"]+)"', replace_link, html_content)


def build_documentation(
    input_files: Sequence[Path],
    output_path: Path,
    template_path: Path | None = None,
    *,
    repo_url: str | None = None,
    title: str | None = None,
    footer: str | None = None,
) -> None:
    """
    Build the documentation HTML file from input files.

    Converts multiple files into a single HTML documentation site
    with navigation, table of contents, and syntax highlighting.

    Markdown files (.md, .markdown) are processed with full Markdown support.
    Other text files are displayed as plain text with preserved formatting.

    Args:
        input_files: List of files to convert (Markdown or plain text)
        output_path: Path where the output HTML file will be written
        template_path: Optional custom HTML template. Defaults to built-in template.
        repo_url: Optional repository URL to link in navigation
        title: Optional documentation title. Falls back to first H1 in first file.
        footer: Optional custom footer text. Defaults to build timestamp.

    Raises:
        FileNotFoundError: If input files or template don't exist
        OSError: If unable to write output file

    """
    # ========== Setup ==========
    # Set default template if not provided
    if template_path is None:
        template_path = Path(__file__).parent / "templates" / "default" / "default.html"

    # ========== Process input files ==========
    # First pass: collect section IDs for internal link rewriting
    section_ids = {input_file.stem.lower() for input_file in input_files}

    # Convert each input file to HTML
    converted_sections = []
    extracted_title = None

    for input_file in input_files:
        sys.stdout.write(f"Reading {input_file}\n")
        file_content = input_file.read_text(encoding="utf-8")

        # Check if file is markdown or plain text
        is_markdown = input_file.suffix.lower() in {".md", ".markdown"}

        if is_markdown:
            sys.stdout.write(f"Converting {input_file.name} to HTML...\n")
            html_content, md_instance = convert_markdown_to_html(file_content)

            # Extract title from first file only (if not provided)
            if extracted_title is None:
                extracted_title = extract_title_from_markdown_instance(md_instance)
        else:
            sys.stdout.write(f"Converting {input_file.name} as plain text...\n")
            html_content = convert_plain_text_to_html(file_content)

        # Rewrite internal links to point to sections instead of files
        html_content = rewrite_internal_links(html_content, section_ids)

        # Build section data
        section_id = input_file.stem.lower()
        converted_sections.append(
            {
                "id": section_id,
                "name": input_file.stem,
                "html": html_content,
            }
        )

    # ========== Prepare template data ==========
    # Use provided title, or fall back to extracted title, or use default
    final_title = title or extracted_title or "Documentation"

    # Use custom footer text or generate timestamp
    build_timestamp = (
        footer or f"Generated: {datetime.now(UTC).strftime('%Y-%m-%d %H:%M:%S UTC')}"
    )

    # ========== Load and render template ==========
    sys.stdout.write(f"Reading template from {template_path}\n")
    template_content = template_path.read_text(encoding="utf-8")

    template = Template(template_content)
    html_output = template.render(
        title=final_title,
        sections=converted_sections,
        repo_url=repo_url,
        build_timestamp=build_timestamp,
    )

    sys.stdout.write(f"Writing output to {output_path}\n")
    output_path.write_text(html_output, encoding="utf-8")

    sys.stdout.write(f"âœ“ Documentation built successfully: {output_path}\n")
    sys.stdout.write(f"  Size: {output_path.stat().st_size:,} bytes\n")
